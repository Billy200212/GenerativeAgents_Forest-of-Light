<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Generative Agents Replay</title>
    
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #222; }
        
        /* --- ä¿®æ”¹å¤„ 1: è°ƒæ•´æ¸¸æˆå®¹å™¨é«˜åº¦ (Billy2025/12/13)--- */
        #game-container {
            width: 100vw;
            height: 75vh; /* åªå ç”¨å±å¹•é«˜åº¦çš„ 75%ï¼Œä¸‹æ–¹ç•™å‡ºç©ºé—´ */
            border-bottom: 2px solid #444; /* æ·»åŠ ä¸€æ¡åº•éƒ¨åˆ†å‰²çº¿ */
            box-sizing: border-box;
        }

        /* åº•éƒ¨ç•™ç™½åŒºåŸŸçš„å ä½ç¬¦ï¼ˆå¯é€‰ï¼Œç”¨äºè§†è§‰ç¡®è®¤ï¼‰ */
        #bottom-panel-placeholder {
            width: 100vw;
            height: 25vh;
            background-color: #1a1a1a;
            color: #555;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
        }

        /* UI æ‡¸æµ®å±¤ - å›ºå®šå·¦ä¸Šè§’ */
        #ui-layer {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-family: 'Microsoft YaHei', 'é»‘ä½“', sans-serif;
            pointer-events: none; /* å®¹å™¨ä¸é˜»æ“‹é¼ æ¨™ */
        }

        /* UI è¡Œå®¹å™¨ */
        .ui-row {
            display: flex;
            gap: 10px;
            pointer-events: auto; /* æŒ‰éˆ•å¯é»æ“Š */
        }

        /* æŒ‰éˆ•æ¨£å¼ */
        .game-btn {
            background-color: #ffffcc;
            border: 2px solid #666;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }

        .game-btn:hover { background-color: #ffffaa; transform: scale(1.05); }
        .game-btn:active { transform: scale(0.95); }

        /* æ™‚é–“é¡¯ç¤ºæ¨£å¼ */
        #time-display {
            background-color: rgba(0, 0, 0, 0.6);
            color: #ccffcc;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 18px;
            pointer-events: auto;
            border: 1px solid #ccffcc;
        }

        /* å°è©±æ¡†æ¨£å¼ */
        #conversation-box {
            background-color: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 15px;
            border-radius: 8px;
            max-width: 500px;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            font-size: 14px;
            line-height: 1.6;
            pointer-events: auto;
            border: 1px solid #aaa;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="ui-row">
            <button id="btn-play" class="game-btn">â–¶ é‹è¡Œ</button>
            <button id="btn-conversation" class="game-btn">ğŸ’¬ æ˜¾ç¤ºå¯¹è¯</button>
        </div>
        <div class="ui-row">
            <div id="time-display">åŠ è½½ä¸­...</div>
        </div>
        <div id="conversation-box">æš‚æ— å¯¹è¯è®°å½•</div>
    </div>

    <!-- æ¸¸æˆåŒºåŸŸ -->
    <div id="game-container"></div>

    <!-- è¿™é‡Œçš„ div åªæ˜¯ä¸ºäº†å æ®ç©ºé—´ï¼Œå®é™…é¡¹ç›®ä¸­ä½ çš„ Flask æ¨¡æ¿å¯èƒ½ä¼šåœ¨è¿™é‡Œæ¸²æŸ“è§’è‰²æ  -->
    <div id="bottom-panel-placeholder">
        <!-- å¯ä»¥åœ¨è¿™é‡Œæ”¾ç½®ä½ çš„è§’è‰²ä¿¡æ¯æ  -->
    </div>

    <div id="temp_focus" style="display:none;"></div>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>

    <script type="text/javascript">
        // --- åˆå§‹åŒ– Flask å˜é‡ ---
        let step = {{ step|tojson }};
        let step_size = {{ sec_per_step|tojson }} * 1000; 
        let zoom = {{ zoom|tojson }};
        if (zoom <= 0) zoom = 0.5;

        let tile_width = 32;
        let movement_speed = {{ play_speed|tojson }};
        let execute_count_max = tile_width / movement_speed;
        let execute_count = execute_count_max;
        let all_movement = {{ all_movement|tojson }};

        let datetime_options = { weekday: "long", year: "numeric", month: "long", day: "numeric" };
        let start_datetime = new Date(Date.parse({{ start_datetime|tojson }}));

        // è§’è‰²æ•°æ®
        let persona_names = {{ persona_init_pos|tojson }};
        var spawn_tile_loc = {};
        for (var key in persona_names) {
            spawn_tile_loc[key] = persona_names[key];
        }

        var personas = {};
        var pronunciatios = {};
        let anims_direction;
        let pre_anims_direction;
        let pre_anims_direction_dict = {};
        let movement_target = {};

        // çŠ¶æ€å˜é‡
        let finished = false;
        let paused = true; 
        let camera_locked = false;
        let focused_persona = null;

        // UI å…ƒç´ 
        const btnPlay = document.getElementById('btn-play');
        const btnConv = document.getElementById('btn-conversation');
        const txtTime = document.getElementById('time-display');
        const boxConv = document.getElementById('conversation-box');

        // åœ°å›¾å°ºå¯¸å˜é‡
        let mapWidth = 0;
        let mapHeight = 0;

        // --- ä¿®æ”¹å¤„ 2: Phaser é…ç½®é€‚é…å®¹å™¨å°ºå¯¸ (Billy2025/12/13) ---
        const gameContainer = document.getElementById('game-container');
        
        const config = {
            type: Phaser.AUTO,
            // ä½¿ç”¨å®¹å™¨çš„å®é™…å®½é˜”ï¼Œè€Œä¸æ˜¯çª—å£çš„å®½åº¦
            width: gameContainer.clientWidth,
            height: gameContainer.clientHeight,
            parent: "game-container",
            mode: Phaser.Scale.RESIZE, // å…è®¸éšå®¹å™¨å¤§å°æ”¹å˜
            pixelArt: true,
            physics: {
                default: "arcade",
                arcade: { gravity: { y: 0 } }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);
        let cursors;
        let player; // ç›¸æœºè·Ÿéšé”šç‚¹ (éšè—çš„ç²¾çµ)
        let mainCamera;
        let map; // åœ°å›¾å¼•ç”¨

        // --- 1. Preload ---
        function preload() {
            this.load.crossOrigin = "";
            this.load.image("forestmap", "static/assets/village/tilemap/forestmap.png");
            this.load.tilemapTiledJSON("map", "static/assets/village/tilemap/tilemap.json");

            this.load.atlas("atlas", "static/assets/village/agents/å°çƒé¾œ/texture.png", "static/assets/village/agents/sprite.json");
            for (var p in persona_names) {
                let image_static = "static/assets/village/agents/" + p + "/texture.png";
                this.load.atlas(p, image_static, "static/assets/village/agents/sprite.json");
            }
        }

        // --- 2. Create ---
        function create() {
            map = this.make.tilemap({ key: "map" });
            const forestmapTileset = map.addTilesetImage("forestmap", "forestmap");
            let tileset_group = [forestmapTileset]; 

            mapWidth = map.widthInPixels;
            mapHeight = map.heightInPixels;

            // --- åˆ›å»ºåœ°å›¾å›¾å±‚ ---
            map.createLayer("mainmap", tileset_group, 0, 0);
            map.createLayer("1äººé¡å€åŸŸ", tileset_group, 0, 0);
            map.createLayer("1æ²³æµä¸‹æ¸¸", tileset_group, 0, 0);
            map.createLayer("1æ²³æµä¸Šæ¸¸", tileset_group, 0, 0);
            map.createLayer("1é“è·¯", tileset_group, 0, 0);
            
            const houseLayers = [
                "1å°ç†Šå®¶", "1å°å…”å­å®¶", "1å°æ¾é¼ å®¶", "1å°çƒé¾œå®¶", "1å°ç¾Šå®¶", "1å°è²“å®¶",
                "2å°ç†Šå®¶å®¢å»³", "2å°ç†Šå®¶è‡¥å®¤", "2å°å…”å­å®¶å®¢å»³", "2å°å…”å­å®¶è‡¥å®¤", "2å°å…”å­å®¶èœåœ’",
                "2å°æ¾é¼ å®¶å®¢å»³", "2å°æ¾é¼ å®¶è‡¥å®¤", "2å°çƒé¾œå®¶å®¢å»³", "2å°çƒé¾œå®¶è‡¥å®¤", "2å°çƒé¾œå®¶èœåœ’",
                "2å°ç¾Šå®¶å®¢å»³", "2å°ç¾Šå®¶è‡¥å®¤", "2å°è²“å®¶å®¢å»³", "2å°è²“å®¶è‡¥å®¤", "2ç¥ç§˜é ˜åŸŸ"
            ];
            houseLayers.forEach(name => {
                const layer = map.createLayer(name, tileset_group, 0, 0);
                if (!layer) console.log(`å›¾å±‚ ${name} åˆ›å»ºå¤±è´¥`);
            });

            const furnitureLayers = [
                "3å°ç†Šå®¶æ²™ç™¼", "3åºŠ", "3å°å…”å­å®¶æ²™ç™¼", "3å°æ¾é¼ å®¶æ²™ç™¼", "3å°çƒé¾œå®¶å‡³å­",
                "3å°ç¾Šå®¶æ²™ç™¼", "3å°è²“å®¶å‡³å­", "3å…‰ä¹‹æº"
            ];
            furnitureLayers.forEach(name => {
                const l = map.createLayer(name, tileset_group, 0, 0);
                if(l) l.setDepth(2);
            });

            // --- ç›¸æœºè®¾ç½® ---
            player = this.physics.add.sprite(mapWidth / 2, mapHeight / 2, "atlas", "down").setSize(30, 40);
            player.setVisible(false);

            mainCamera = this.cameras.main;
            mainCamera.startFollow(player);
            // åˆå§‹æ—¶ä½¿ç”¨è¾¹ç•Œé™åˆ¶
            mainCamera.setBounds(0, 0, mapWidth, mapHeight);
            mainCamera.setZoom(zoom);

            cursors = this.input.keyboard.createCursorKeys();

            // --- è§’è‰²ç”Ÿæˆ ---
            for (let i=0; i<Object.keys(spawn_tile_loc).length; i++) {
                let p_name = Object.keys(spawn_tile_loc)[i];
                let start_pos = [spawn_tile_loc[p_name][0] * tile_width + tile_width / 2, spawn_tile_loc[p_name][1] * tile_width + tile_width];
                
                let new_sprite = this.physics.add.sprite(start_pos[0], start_pos[1], p_name, "down").setSize(30, 40).setOffset(0, 0);
                new_sprite.displayWidth = 40;
                new_sprite.scaleY = new_sprite.scaleX;
                
                personas[p_name] = new_sprite;
                pronunciatios[p_name] = this.add.text(
                    new_sprite.body.x - 15, new_sprite.body.y - 40, "", 
                    { font: "18px monospace", fill: "#000000", backgroundColor: "#ffffcc", padding: { x: 4, y: 4}, borderRadius:"10px" }
                ).setDepth(3).setAlpha(0.7);
            }

            // --- åŠ¨ç”» ---
            const anims = this.anims;
            for (let i = 0; i < Object.keys(persona_names).length; i++) {
                let p_name = Object.keys(persona_names)[i];
                let fr = movement_speed > 1 ? 8 : 4;
                ['left', 'right', 'down', 'up'].forEach(dir => {
                    anims.create({
                        key: `${p_name}-${dir}-walk`,
                        frames: anims.generateFrameNames(p_name, { prefix: `${dir}-walk.`, start: 0, end: 3, zeroPad: 3 }),
                        frameRate: fr,
                        repeat: -1
                    });
                });
            }

            // --- é¼ æ ‡æ‹–æ‹½é€»è¾‘ ---
            let isDragging = false;
            let lastDragPoint = null;
            
            this.input.on('pointerdown', (pointer) => {
                if (pointer.middleButtonDown()) {
                    isDragging = true;
                    lastDragPoint = { x: pointer.x, y: pointer.y };
                    camera_locked = false;
                    focused_persona = null;
                    mainCamera.stopFollow();
                }
            });
            
            this.input.on('pointermove', (pointer) => {
                if (isDragging && lastDragPoint) {
                    const dx = (pointer.x - lastDragPoint.x) / mainCamera.zoom;
                    const dy = (pointer.y - lastDragPoint.y) / mainCamera.zoom;
                    mainCamera.scrollX -= dx;
                    mainCamera.scrollY -= dy;
                    lastDragPoint.x = pointer.x;
                    lastDragPoint.y = pointer.y;
                }
            });
            
            this.input.on('pointerup', (pointer) => {
                if (pointer.middleButtonReleased()) {
                    isDragging = false;
                    lastDragPoint = null;
                    if (!camera_locked) {
                        player.setPosition(mainCamera.worldView.centerX, mainCamera.worldView.centerY);
                        mainCamera.startFollow(player);
                    }
                }
            });
            
            this.input.on('gameout', () => {
                isDragging = false;
                lastDragPoint = null;
            });

            // ==========================================
            //       æœ€ç»ˆä¿®å¤ç‰ˆï¼šæ— ç¼ç¼©æ”¾ & åŠ¨æ€è¾¹ç•Œ
            // ==========================================
            this.input.on('wheel', (pointer, gameObjects, deltaX, deltaY, deltaZ) => {
                const viewportW = mainCamera.width;
                const viewportH = mainCamera.height;
                const minZoom = Math.min(viewportW / mapWidth, viewportH / mapHeight);

                let currentZoom = mainCamera.zoom;
                if (deltaY > 0) currentZoom *= 0.9; 
                else currentZoom *= 1.1;

                if (currentZoom < minZoom) currentZoom = minZoom; 
                if (currentZoom > 4) currentZoom = 4;

                mainCamera.setZoom(currentZoom);
                checkAndApplyBounds();
            });

            // åˆå§‹è¿è¡Œä¸€æ¬¡è¾¹ç•Œæ£€æŸ¥ï¼Œç¡®ä¿ä¸€å¼€å§‹è‹¥åœ°å›¾è¾ƒå°èƒ½å±…ä¸­
            checkAndApplyBounds();

            setupUI();
        }

        /**
         * æ ¸å¿ƒè¾…åŠ©å‡½æ•°ï¼šåŠ¨æ€è¾¹ç•Œæ§åˆ¶
         * å¦‚æœåœ°å›¾çœ‹èµ·æ¥æ¯”å±å¹•å°ï¼Œç§»é™¤è¾¹ç•Œï¼ˆå…è®¸å±…ä¸­ï¼‰ï¼›å¦åˆ™åº”ç”¨è¾¹ç•Œï¼ˆé˜²æ­¢é»‘è¾¹ï¼‰ã€‚
         */
        function checkAndApplyBounds() {
            const viewportW = mainCamera.width;
            const viewportH = mainCamera.height;
            const scaledMapW = mapWidth * mainCamera.zoom;
            const scaledMapH = mapHeight * mainCamera.zoom;

            // ä½¿ç”¨ä¸€ä¸ªå°çš„å®¹å·®å€¼ (1px) é¿å…æµ®ç‚¹æ•°è®¡ç®—å¯¼è‡´çš„é—ªçƒ
            if (scaledMapW < viewportW + 1 || scaledMapH < viewportH + 1) {
                if (mainCamera.useBounds) {
                    mainCamera.removeBounds();
                }
            } else {
                if (!mainCamera.useBounds) {
                    mainCamera.setBounds(0, 0, mapWidth, mapHeight);
                }
            }
        }

        function setupUI() {
            btnPlay.onclick = () => {
                if (finished) {
                    window.location.reload(); 
                } else {
                    paused = !paused;
                    updateBtnState();
                }
            };
            btnConv.onclick = () => {
                if (boxConv.style.display === 'none') {
                    boxConv.style.display = 'block';
                    btnConv.innerText = 'ğŸ’¬ éšè—å¯¹è¯';
                } else {
                    boxConv.style.display = 'none';
                    btnConv.innerText = 'ğŸ’¬ æ˜¾ç¤ºå¯¹è¯';
                }
            };
            updateBtnState();
        }

        function updateBtnState() {
            if (finished) {
                btnPlay.innerText = "â†» é‡æ’­";
                btnPlay.style.backgroundColor = "#ff9999";
            } else if (paused) {
                btnPlay.innerText = "â–¶ è¿è¡Œ";
                btnPlay.style.backgroundColor = "#ffffcc";
            } else {
                btnPlay.innerText = "â¸ æš‚åœ";
                btnPlay.style.backgroundColor = "#ccffcc";
            }
        }

        // --- 3. Update ---
        function update(time, delta) {
            checkAndApplyBounds();

            // å¤–éƒ¨ç‚¹å‡»é”å®šé€»è¾‘
            let dom_focus = document.getElementById("temp_focus").textContent;
            if (dom_focus !== "") {
                focused_persona = dom_focus;
                camera_locked = true;
                document.getElementById("temp_focus").innerHTML = ""; 
                if (personas[focused_persona]) {
                    mainCamera.startFollow(personas[focused_persona], true, 0.08, 0.08);
                    mainCamera.zoomTo(2, 1000, 'Power2'); 
                }
            }

            // é”®ç›˜ç§»åŠ¨ç›¸æœº
            const camSpeed = 500 / mainCamera.zoom;
            if (!camera_locked) {
                player.body.setVelocity(0);
                if (cursors.left.isDown) player.body.setVelocityX(-camSpeed);
                else if (cursors.right.isDown) player.body.setVelocityX(camSpeed);
                if (cursors.up.isDown) player.body.setVelocityY(-camSpeed);
                else if (cursors.down.isDown) player.body.setVelocityY(camSpeed);

                // å¦‚æœæŒ‰é”®ï¼Œç¡®ä¿è·Ÿéšçš„æ˜¯ player é”šç‚¹
                if (cursors.left.isDown || cursors.right.isDown || cursors.up.isDown || cursors.down.isDown) {
                     mainCamera.startFollow(player);
                }
            } else {
                if (cursors.left.isDown || cursors.right.isDown || cursors.up.isDown || cursors.down.isDown) {
                    camera_locked = false;
                    focused_persona = null;
                    player.body.x = mainCamera.worldView.centerX;
                    player.body.y = mainCamera.worldView.centerY;
                    mainCamera.startFollow(player);
                }
            }

            if (finished || paused) return;

            // æ›´æ–°æ•°æ®
            curr_datetime = new Date(start_datetime.getTime());
            txtTime.innerText = curr_datetime.toLocaleTimeString("zh-CN", datetime_options);

            let key = `${curr_datetime.getFullYear()}${(curr_datetime.getMonth()+1).toString().padStart(2,"0")}${curr_datetime.getDate().toString().padStart(2,"0")}-${curr_datetime.getHours().toString().padStart(2,"0")}:${curr_datetime.getMinutes().toString().padStart(2,"0")}`;
            if (all_movement["conversation"] && all_movement["conversation"][key]) {
                boxConv.innerHTML = `<strong>${key}</strong><br>${all_movement["conversation"][key]}`;
            }

            // ç§»åŠ¨é€»è¾‘
            for (let i = 0; i < Object.keys(personas).length; i++) {
                let p_name = Object.keys(personas)[i];
                let curr_persona = personas[p_name];
                let curr_pronun = pronunciatios[p_name];

                if (step in all_movement && p_name.replace("_", " ") in all_movement[step]) {
                    if (execute_count == execute_count_max) {
                        let data = all_movement[step][p_name.replace("_", " ")];
                        movement_target[p_name] = [
                            data["movement"][0] * tile_width + tile_width / 2, 
                            data["movement"][1] * tile_width + tile_width
                        ];
                        let act = data["action"];
                        curr_pronun.setText(`${p_name}: ${act.length > 15 ? act.substring(0,12)+"..." : act}`);
                        
                        let descEl = document.getElementById("agent_desc__"+p_name);
                        if(descEl) descEl.innerHTML = all_movement["description"][p_name]["currently"];
                        let actEl = document.getElementById("current_action__"+p_name);
                        if(actEl) actEl.innerHTML = act;
                        let locEl = document.getElementById("target_address__"+p_name);
                        if(locEl) locEl.innerHTML = data["location"];
                    }

                    if (execute_count > 0 && movement_target[p_name]) {
                        let tx = movement_target[p_name][0];
                        let ty = movement_target[p_name][1];
                        let dx = tx - curr_persona.x;
                        let dy = ty - curr_persona.y;
                        
                        let isMoving = false;
                        if (Math.abs(dx) > 0.5) {
                            curr_persona.x += dx > 0 ? movement_speed : -movement_speed;
                            anims_direction = dx > 0 ? 'r' : 'l';
                            isMoving = true;
                        } else if (Math.abs(dy) > 0.5) {
                            curr_persona.y += dy > 0 ? movement_speed : -movement_speed;
                            anims_direction = dy > 0 ? 'd' : 'u';
                            isMoving = true;
                        }

                        if (isMoving) {
                            let dirName = anims_direction === 'l' ? 'left' : anims_direction === 'r' ? 'right' : anims_direction === 'u' ? 'up' : 'down';
                            curr_persona.anims.play(`${p_name}-${dirName}-walk`, true);
                            pre_anims_direction_dict[p_name] = dirName;
                        } else {
                            let lastDir = pre_anims_direction_dict[p_name] || 'down';
                            curr_persona.anims.stop();
                            curr_persona.setTexture(p_name, `${lastDir}-walk.000`);
                        }
                        
                        curr_pronun.x = curr_persona.x - 15;
                        curr_pronun.y = curr_persona.y - 40;
                    }
                }
            }

            if (execute_count == 0) {
                for (let p in personas) {
                    if (movement_target[p]) {
                        personas[p].x = movement_target[p][0];
                        personas[p].y = movement_target[p][1];
                    }
                }
                execute_count = execute_count_max + 1;
                step++;
                start_datetime = new Date(start_datetime.getTime() + step_size);
                
                if (!(step in all_movement)) {
                    finished = true;
                    updateBtnState();
                }
            }
            execute_count--;
        }
    </script>
</body>
</html>